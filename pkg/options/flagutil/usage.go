package flagutil

import (
	"fmt"
	"strings"

	"github.com/charmbracelet/x/ansi"
	"github.com/spf13/pflag"
)

// UsageFormatOptions is used to format flag usage output.
type UsageFormatOptions struct {
	// Columns sets the column wrapping.
	Columns int
	// Indentation sets the leading indent for each line.
	Indentation *string
	// FormatFlagName is used to format the name of each flag.
	FormatFlagName func(flag *pflag.Flag, name string) string
	// FormatType is called to format the type of each flag.
	FormatType func(flag *pflag.Flag, typeName string) string
	// FormatValue is called to format flag values for defaults and no-op defaults for each flag.
	FormatValue func(flag *pflag.Flag, value string) string
	// FormatUsage is called to format the flag usage string.
	FormatUsage func(flag *pflag.Flag, usage string) string
	// LineFunc overrides all other functions.
	LineFunc func(flag *pflag.Flag) (line string, skip bool)
}

// FlagUsages returns a string containing the usage information for all flags in
// the FlagSet
func FlagUsages(f *pflag.FlagSet, opts UsageFormatOptions) string {
	if f == nil {
		return ""
	}

	indent := "  "
	if opts.Indentation != nil {
		indent = *opts.Indentation
	}

	buf := new(strings.Builder)

	lines := []string{}

	maxlen := 0
	f.VisitAll(func(flag *pflag.Flag) {
		if opts.LineFunc != nil {
			line, skip := opts.LineFunc(flag)
			if !skip {
				lines = append(lines, line)
			}
			return
		}

		if flag.Hidden {
			return
		}

		line := indent
		line += fmtName(flag, opts)

		varname, usage := pflag.UnquoteUsage(flag)
		if varname != "" {
			if opts.FormatType != nil {
				varname = opts.FormatType(flag, varname)
			}
			line += " " + varname
		}

		// Add NoOptDefVal if set
		if noOptDefVal := fmtNoOptDefVal(flag, opts); noOptDefVal != "" {
			line += noOptDefVal
		}

		// This special character will be replaced with spacing once the
		// correct alignment is calculated
		line += rhsStartChar
		linelen := ansi.StringWidth(line)
		if linelen > maxlen {
			maxlen = linelen
		}

		// Add usage description
		if opts.FormatUsage != nil {
			usage = opts.FormatUsage(flag, usage)
		}
		line += usage

		// Add default value
		if def := fmtDefault(flag, DefaultIsZeroValue(flag), opts); def != "" {
			line += " " + def
		}

		// Add deprecated notice
		if len(flag.Deprecated) != 0 {
			line += fmt.Sprintf(" (DEPRECATED: %s)", flag.Deprecated)
		}

		lines = append(lines, line)
	})

	for _, line := range lines {
		before, after, found := strings.Cut(line, rhsStartChar)
		if found {
			spacing := strings.Repeat(" ", maxlen-ansi.StringWidth(before))
			prefixlen := maxlen + 2
			after = ansi.Wordwrap(after, max(opts.Columns-prefixlen, 0), " ")
			after = strings.ReplaceAll(after, "\n", "\n"+strings.Repeat(" ", prefixlen))
			// maxlen + 2 comes from + 1 for the \x00 and + 1 for the (deliberate) off-by-one in maxlen-sidx
			_, _ = fmt.Fprintln(buf, before, spacing, after)
		} else {
			// Can assume the line was generated by opts.LineFunc and cannot be reformatted like others.
			_, _ = fmt.Fprintln(buf, line)
		}
	}

	return buf.String()
}

const (
	// rhsStartChar marks the start of the RHS of a flag description
	rhsStartChar = "\x00"
)

func fmtName(flag *pflag.Flag, opts UsageFormatOptions) string {
	namer := opts.FormatFlagName
	if namer == nil {
		namer = func(flag *pflag.Flag, name string) string { return name }
	}
	if flag.Shorthand != "" && flag.ShorthandDeprecated == "" {
		return fmt.Sprintf("%s, %s", namer(flag, "-"+flag.Shorthand), namer(flag, "--"+flag.Name))
	}
	return fmt.Sprintf("    %s", namer(flag, "--"+flag.Name))
}

func fmtNoOptDefVal(flag *pflag.Flag, opts UsageFormatOptions) string {
	if flag.NoOptDefVal != "" {
		noOptDefVal := flag.NoOptDefVal
		if opts.FormatValue != nil {
			noOptDefVal = opts.FormatValue(flag, flag.NoOptDefVal)
		}
		switch flag.Value.Type() {
		case "string":
			return fmt.Sprintf("[=\"%s\"]", noOptDefVal)
		case "bool":
			if flag.NoOptDefVal != "true" {
				return fmt.Sprintf("[=%s]", noOptDefVal)
			}
		case "count":
			if flag.NoOptDefVal != "+1" {
				return fmt.Sprintf("[=%s]", noOptDefVal)
			}
		default:
			return fmt.Sprintf("[=%s]", noOptDefVal)
		}
	}
	return ""
}

func fmtDefault(flag *pflag.Flag, defaultIsZeroValue bool, opts UsageFormatOptions) string {
	if defaultIsZeroValue {
		return ""
	}
	defValue := flag.DefValue
	if flag.Value.Type() == "string" {
		defValue = fmt.Sprintf("%q", defValue)
	}
	if opts.FormatValue != nil {
		defValue = opts.FormatValue(flag, defValue)
	}
	return fmt.Sprintf("(default %s)", defValue)
}

// DefaultIsZeroValue returns true if the default value for this flag represents
// a zero value.
//
// This is a best effort guess.
func DefaultIsZeroValue(f *pflag.Flag) bool {
	switch f.Value.Type() {
	case "bool":
		return f.DefValue == "false"
	case "duration":
		// Beginning in Go 1.7, duration zero values are "0s"
		return f.DefValue == "0" || f.DefValue == "0s"
	case "int", "int8", "int16", "int32", "int64",
		"uint", "uint8", "uint16", "uint32", "uint64",
		"float32", "float64", "count":
		return f.DefValue == "0"
	case "string":
		return f.DefValue == ""
	case "ip", "ipMask", "ipNet":
		return f.DefValue == "<nil>"
	case "intSlice", "stringSlice", "stringArray":
		return f.DefValue == "[]"
	default:
		switch f.Value.String() {
		case "false":
			return true
		case "<nil>":
			return true
		case "":
			return true
		case "[]":
			return true
		case "0":
			return true
		}
		return false
	}
}
